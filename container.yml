version: "2"
settings:

#  conductor:
#    # The Conductor container does the heavy lifting, and provides a portable
#    # Python runtime for building your target containers. It should be derived
#    # from the same distribution as you're building your target containers with.
#    base: centos:7
#    roles_path: ansible-thredds-cluster/roles
#    # volumes:      # Provide a list of volumes to mount
#    # environment:  # List or mapping of environment variables
#
#  # Set the name of the project. Defaults to basename of the project directory.
#  # For built services, concatenated with service name to form the built image name.
#  project_name: tds-cluster-test
#
#  # The deployment_output_path is mounted to the Conductor container, and the 
#  # `run` and `deployment` commands then write generated Ansible playbooks to it.
#  # deployment_output_path: ./ansible-deployment
#
#  # When using the k8s or openshift engines, use the following to authorize with the API.
#  # Values set here will be passed to the Ansible modules. Any file paths will be mounted
#  # to the conductor container, allowing the `run` command to access the API.
#  #k8s_auth:
#    # path to a K8s config file
#    #config_file:
#    # name of a context found within the config file
#    #context:
#    # URL for accessing the K8s API
#    #host:
#    # An API authentication token
#    #api_key:
#    # Path to a ca cert file
#    #ssl_ca_cert:
#    # Path to a cert file
#    #cert_file:
#    # Path to a key file
#    #key_file:
#    # boolean, indicating if SSL certs should be validated
#    #verify_ssl:
#
#  # When using the k8s or openshift engines, use the following to set the namespace.
#  # If not set, the project name will be used. For openshift, the namespace maps to a project,
#  # and description and display_name are supported.
#  #k8s_namespace:
#  #  name:
#  #  description:
#  #  display_name:

defaults:
  collections:
    - &collection1
      path: collection1 # Id of the collection and logical path in THREDDS
      top: True # Add a reference in the tds gateway to the collection
      references: ['collection2'] # Have I implemented this?
      mode: '2775'
      catalogs:
        src: data/collection1
        _owner: zequi
      services: [catalog, fileServer, dodsC]

    - &collection2
      path: collection2
      top: True
      catalogs:
        src: data/collection2
      services: [dap4, dodsC, catalog, fileServer, ncss/grid]

services:
  gateway:
    from: "cedadev/esgf-proxy" # nginx
    roles:
      - role: gateway-jk-tds
        backend: miniconda
        miniconda_pyhon: 3
        miniconda_prefix: "/root/miniconda3"
        miniconda_env:
          name: httpd
          channels:
            - zequihg50
          dependencies:
            - httpd-jk
        collections:
          - *collection1
          - *collection2
  tds:
    from: "cedadev/esgf-tds"
    roles:
      - role: tds
        rita: miniconda
        miniconda_pyhon: 3
        miniconda_prefix: "/root/miniconda3"
        miniconda_env:
          name: tds
          channels:
            - birdhouse
          dependencies:
            - python=2.7 # supervisor requires python2
            - libnetcdf # for ncss
            - supervisor # for management of the instances
            - apache-tomcat
      - role: tds-modjk
      - role: supervisor-tds
  # Add your containers here, specifying the base image you want to build from.
  # To use this example, uncomment it and delete the curly braces after services key.
  # You may need to run `docker pull ubuntu:trusty` for this to work.

  # web:
  #   from: "centos:7"
  #   ports:
  #     - "80:80"
  #   command: ["/usr/bin/dumb-init", "/usr/sbin/apache2ctl", "-D", "FOREGROUND"]
  #   dev_overrides:
  #     environment:
  #       - "DEBUG=1"
registries: {}
  # Add optional registries used for deployment. For example:
  #  google:
  #    url: https://gcr.io
  #    namespace: my-cool-project-xxxxxx   
